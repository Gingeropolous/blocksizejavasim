<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Blockchain Simulator (Corrected)</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { background-color: #f8f9fa; padding-bottom: 50px; }
        .config-card { border-left: 5px solid #0d6efd; margin-bottom: 20px; }
        .chart-card { height: 350px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        .chart-card-lg { height: 500px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        .chart-container { position: relative; height: 100%; width: 100%; }
        .form-label { font-weight: 600; font-size: 0.9rem; margin-bottom: 2px;}
        .form-text { font-size: 0.75rem; color: #6c757d; display: block; margin-top: 0;}
        
        /* Loading Overlay */
        #loadingOverlay {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255,255,255,0.85); z-index: 2000; 
            flex-direction: column; justify-content: center; align-items: center;
        }
        .version-badge {
            background: #198754;
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
            margin-left: 10px;
        }
    </style>
</head>
<body>

<div id="loadingOverlay">
    <div class="spinner-border text-primary" style="width: 3rem; height: 3rem;" role="status"></div>
    <h4 class="mt-3 text-primary">Running Simulation...</h4>
    <p class="text-muted">Calculating medians and mempool growth</p>
    <div id="progressText" class="text-muted"></div>
</div>

<div class="container-fluid p-4">
    <h2 class="mb-4">
        Blockchain Growth & Fee Simulator
        <span class="version-badge">Corrected v2.0</span>
    </h2>
    <h3> WARNING: AI GENERATED. Original human code can be found here: https://github.com/spackle-xmr/Dynamic_Block_Demo/blob/main/Dynamic_Blocksize_econ_draft.py</h3>

    <div class="card config-card shadow-sm">
        <div class="card-header bg-white d-flex justify-content-between align-items-center">
            <h5 class="m-0 text-primary">Simulation Parameters</h5>
            <button class="btn btn-success" onclick="startSimulation()">
                &#9658; Run Simulation
            </button>
        </div>
        <div class="card-body">
            <form id="simForm">
                <div class="row g-3">
                    
                    <div class="col-md-3 border-end">
                        <h6 class="text-uppercase text-muted fw-bold" style="font-size: 0.75rem;">Network Constants</h6>
                        
                        <div class="mb-2">
                            <label class="form-label">Steady State (Bytes)</label>
                            <input type="number" id="steady_state" class="form-control form-control-sm" value="300000">
                            <small class="form-text">Network blocksize at start (M_L, M_S initial)</small>
                        </div>

                        <div class="mb-2">
                            <label class="form-label">Z_M (Penalty Free Zone)</label>
                            <input type="number" id="z_m" class="form-control form-control-sm" value="300000">
                            <small class="form-text">Guaranteed penalty free block weight.</small>
                        </div>

                        <div class="mb-2">
                            <label class="form-label">T_R (Ref Transaction)</label>
                            <input type="number" id="t_r" class="form-control form-control-sm" value="3000">
                            <small class="form-text">Reference tx weight for fee calculation.</small>
                        </div>

                        <div class="mb-2">
                            <label class="form-label">R_Base (Factor)</label>
                            <input type="number" id="r_base" class="form-control form-control-sm" value="0.6" step="0.1">
                            <small class="form-text">Base multiplier for penalty calculation.</small>
                        </div>
                    </div>

                    <div class="col-md-3 border-end">
                        <h6 class="text-uppercase text-muted fw-bold" style="font-size: 0.75rem;">Median Algorithm Tuning</h6>

                        <div class="mb-2">
                            <label class="form-label">mid_100k (Long Term Index)</label>
                            <input type="number" id="mid_100k" class="form-control form-control-sm" value="50000">
                            <small class="form-text">Middle index for Long Term window.</small>
                        </div>

                        <div class="mb-2">
                            <label class="form-label">mid_100 (Short Term Index)</label>
                            <input type="number" id="mid_100" class="form-control form-control-sm" value="50">
                            <small class="form-text">Middle index for Short Term window.</small>
                        </div>

                        <div class="mb-2">
                            <label class="form-label">T_sim (Discretization)</label>
                            <input type="number" id="t_sim" class="form-control form-control-sm" value="800">
                            <small class="form-text">Tx size step (Bytes). Granularity of sim.</small>
                        </div>
                    </div>

                    <div class="col-md-3 border-end">
                        <h6 class="text-uppercase text-muted fw-bold" style="font-size: 0.75rem;">Scenario Settings</h6>

                        <div class="mb-2">
                            <label class="form-label">n (Number of Blocks)</label>
                            <input type="number" id="n" class="form-control form-control-sm" value="20000">
                            <small class="form-text">Total duration of the simulation.</small>
                        </div>

                        <div class="mb-2">
                            <label class="form-label">Traffic Pattern (RUN_TYPE)</label>
                            <select id="run_type" class="form-select form-select-sm">
                                <option value="1">1: Linear Ramp</option>
                                <option value="2">2: Fast Linear Ramp</option>
                                <option value="3">3: Fast Parabolic Ramp</option>
                                <option value="4">4: Fast Exponential Ramp</option>
                                <option value="5">5: Maximum Flood</option>
                                <option value="6" selected>6: Ramp To Sine Wave</option>
                            </select>
                            <small class="form-text">Shape of transaction influx.</small>
                        </div>

                        <div class="mb-2">
                            <label class="form-label">Ramp Multiplier</label>
                            <input type="number" id="ramp_multiplier" class="form-control form-control-sm" value="3" step="0.5">
                            <small class="form-text">End volume / start volume (RUN_TYPE 6)</small>
                        </div>

                        <div class="form-check mt-3">
                            <input class="form-check-input" type="checkbox" id="add_noise">
                            <label class="form-check-label" style="font-size: 0.85rem">ADD_NOISE</label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="users_pay_more">
                            <label class="form-check-label" style="font-size: 0.85rem">USERS_PAY_MORE</label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="large_sim_mode">
                            <label class="form-check-label" style="font-size: 0.85rem">LARGE_SIMULATION_MODE</label>
                        </div>
                    </div>

                    <div class="col-md-3 bg-light p-3 rounded">
                        <h6 class="text-uppercase text-muted fw-bold" style="font-size: 0.75rem;">Results Summary</h6>
                        <div id="statsOutput" class="small">
                            <p class="text-muted">Click "Run Simulation" to generate data.</p>
                        </div>
                    </div>

                </div>
            </form>
        </div>
    </div>

    <div class="row">
        <div class="col-12">
            <div class="card chart-card-lg border-primary">
                <div class="card-header bg-primary text-white py-2">
                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <span><strong>Combined Analysis</strong> (All Metrics)</span>
                        <button class="btn btn-sm btn-light" type="button" data-bs-toggle="collapse" data-bs-target="#scaleControls">
                            ⚙️ Scale Controls
                        </button>
                    </div>
                    <div class="collapse" id="scaleControls">
                        <div class="row g-2 bg-light rounded p-2 text-dark">
                            <div class="col">
                                <label class="form-label mb-0 small">Block Size</label>
                                <div class="input-group input-group-sm">
                                    <span class="input-group-text">×</span>
                                    <input type="number" id="scale_blocksize" class="form-control" value="1" step="0.1" onchange="updateCombinedChart()">
                                </div>
                            </div>
                            <div class="col">
                                <label class="form-label mb-0 small">TxPool Size</label>
                                <div class="input-group input-group-sm">
                                    <span class="input-group-text">×</span>
                                    <input type="number" id="scale_txpool" class="form-control" value="1" step="0.1" onchange="updateCombinedChart()">
                                </div>
                            </div>
                            <div class="col">
                                <label class="form-label mb-0 small">Volume</label>
                                <div class="input-group input-group-sm">
                                    <span class="input-group-text">×</span>
                                    <input type="number" id="scale_volume" class="form-control" value="1" step="0.1" onchange="updateCombinedChart()">
                                </div>
                            </div>
                            <div class="col">
                                <label class="form-label mb-0 small">Fees</label>
                                <div class="input-group input-group-sm">
                                    <span class="input-group-text">×</span>
                                    <input type="number" id="scale_fees" class="form-control" value="1" step="0.1" onchange="updateCombinedChart()">
                                </div>
                            </div>
                            <div class="col">
                                <label class="form-label mb-0 small">Penalty</label>
                                <div class="input-group input-group-sm">
                                    <span class="input-group-text">×</span>
                                    <input type="number" id="scale_penalty" class="form-control" value="1000" step="100" onchange="updateCombinedChart()">
                                </div>
                            </div>
                            <div class="col-auto d-flex align-items-end">
                                <button class="btn btn-sm btn-secondary" onclick="resetScales()">Reset</button>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="card-body">
                    <div class="chart-container">
                        <canvas id="chartCombined"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="row">
        <div class="col-md-6">
            <div class="card chart-card">
                <div class="card-header py-1"><strong>Block Weight / Size</strong> (Bytes)</div>
                <div class="card-body">
                    <div class="chart-container">
                        <canvas id="chartBlockSize"></canvas>
                    </div>
                </div>
            </div>
        </div>
        <div class="col-md-6">
            <div class="card chart-card">
                <div class="card-header py-1 text-danger"><strong>TxPool (Mempool) Size</strong> (Bytes)</div>
                <div class="card-body">
                    <div class="chart-container">
                        <canvas id="chartMempool"></canvas>
                    </div>
                </div>
            </div>
        </div>
        <div class="col-md-4">
            <div class="card chart-card">
                <div class="card-header py-1"><strong>Broadcast Volume</strong> (Bytes/Block)</div>
                <div class="card-body">
                    <div class="chart-container">
                        <canvas id="chartVolume"></canvas>
                    </div>
                </div>
            </div>
        </div>
        <div class="col-md-4">
            <div class="card chart-card">
                <div class="card-header py-1"><strong>Total Fees</strong></div>
                <div class="card-body">
                    <div class="chart-container">
                        <canvas id="chartFees"></canvas>
                    </div>
                </div>
            </div>
        </div>
        <div class="col-md-4">
            <div class="card chart-card">
                <div class="card-header py-1"><strong>Penalty (P_B)</strong></div>
                <div class="card-body">
                    <div class="chart-container">
                        <canvas id="chartPenalty"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="row">
        <div class="col-md-6">
            <div class="card chart-card">
                <div class="card-header py-1"><strong>Long Term Median (M_L)</strong></div>
                <div class="card-body">
                    <div class="chart-container">
                        <canvas id="chartML"></canvas>
                    </div>
                </div>
            </div>
        </div>
        <div class="col-md-6">
            <div class="card chart-card">
                <div class="card-header py-1"><strong>Short Term Median (M_S)</strong></div>
                <div class="card-body">
                    <div class="chart-container">
                        <canvas id="chartMS"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    // --- UTILITIES ---
    // Binary Search for inserting into sorted arrays
    function binarySearch(arr, val) {
        let start = 0, end = arr.length - 1;
        while (start <= end) {
            let mid = Math.floor((start + end) / 2);
            if (arr[mid] === val) return mid;
            if (arr[mid] < val) start = mid + 1;
            else end = mid - 1;
        }
        return start;
    }
    
    function insort(arr, val) {
        arr.splice(binarySearch(arr, val), 0, val);
    }
    
    function removeValue(arr, val) {
        let idx = binarySearch(arr, val);
        // Handle case where binary search finds insertion point, not exact match
        if (idx < arr.length && arr[idx] === val) {
            arr.splice(idx, 1);
        } else {
            // Fallback to indexOf for edge cases
            let exactIdx = arr.indexOf(val);
            if (exactIdx > -1) arr.splice(exactIdx, 1);
        }
    }

    // Box-Muller transform for normal distribution (matches numpy.random.normal)
    function normalRandom(mean, stdDev) {
        let u = 0, v = 0;
        while (u === 0) u = Math.random();
        while (v === 0) v = Math.random();
        let num = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
        return mean + stdDev * num;
    }

    // Store raw data globally for rescaling
    let rawSimData = null;
    
    function updateCombinedChart() {
        if (!rawSimData) return;
        
        const scales = {
            blockSize: parseFloat(document.getElementById('scale_blocksize').value) || 1,
            txPool: parseFloat(document.getElementById('scale_txpool').value) || 1,
            volume: parseFloat(document.getElementById('scale_volume').value) || 1,
            fees: parseFloat(document.getElementById('scale_fees').value) || 1,
            penalty: parseFloat(document.getElementById('scale_penalty').value) || 1000
        };
        
        // Update data with scaling
        charts.combined.data.datasets[0].data = rawSimData.M_B.map(v => v * scales.blockSize);
        charts.combined.data.datasets[1].data = rawSimData.mempool_size.map(v => v * scales.txPool);
        charts.combined.data.datasets[2].data = rawSimData.input_volume.map(v => v * scales.volume);
        charts.combined.data.datasets[3].data = rawSimData.block_fee.map(v => v * scales.fees);
        charts.combined.data.datasets[4].data = rawSimData.penalty.map(v => v * scales.penalty);
        
        // Update labels to show scale factors
        charts.combined.data.datasets[0].label = `Block Size (×${scales.blockSize})`;
        charts.combined.data.datasets[1].label = `TxPool Size (×${scales.txPool})`;
        charts.combined.data.datasets[2].label = `Volume (×${scales.volume})`;
        charts.combined.data.datasets[3].label = `Fees (×${scales.fees})`;
        charts.combined.data.datasets[4].label = `Penalty (×${scales.penalty})`;
        
        charts.combined.update();
    }
    
    function resetScales() {
        document.getElementById('scale_blocksize').value = 1;
        document.getElementById('scale_txpool').value = 1;
        document.getElementById('scale_volume').value = 1;
        document.getElementById('scale_fees').value = 1;
        document.getElementById('scale_penalty').value = 1000;
        updateCombinedChart();
    }

    // --- CHARTS CONFIG ---
    let charts = {};
    function initCharts() {
        const commonOptions = {
            responsive: true,
            maintainAspectRatio: false,
            animation: false,
            elements: { point: { radius: 0, hitRadius: 10, hoverRadius: 4 } },
            plugins: { legend: { display: false }, tooltip: { mode: 'index', intersect: false } },
            scales: { 
                x: { display: true, ticks: { maxTicksLimit: 10 } },
                y: { beginAtZero: true }
            }
        };

        const createChart = (id, label, color) => {
            return new Chart(document.getElementById(id).getContext('2d'), {
                type: 'line',
                data: { labels: [], datasets: [{ label: label, data: [], borderColor: color, borderWidth: 1.5, fill: false }] },
                options: JSON.parse(JSON.stringify(commonOptions))
            });
        };

        // Initialize Single Charts
        charts.blockSize = createChart('chartBlockSize', 'Block Size', '#0dcaf0');
        charts.mempool = createChart('chartMempool', 'TxPool Size', '#fd7e14');
        charts.volume = createChart('chartVolume', 'Broadcast Vol', '#198754');
        charts.fees = createChart('chartFees', 'Total Fees', '#0d6efd');
        charts.penalty = createChart('chartPenalty', 'Penalty', '#dc3545');
        charts.ml = createChart('chartML', 'M_L', '#6f42c1');
        charts.ms = createChart('chartMS', 'M_S', '#20c997');

        // Initialize Combined Chart (Dual Axis)
        const ctxCombined = document.getElementById('chartCombined').getContext('2d');
        charts.combined = new Chart(ctxCombined, {
            type: 'line',
            data: { 
                labels: [], 
                datasets: [
                    { label: 'Block Size (×1)', borderColor: '#0dcaf0', borderWidth: 1.5, data: [], yAxisID: 'y' },
                    { label: 'TxPool Size (×1)', borderColor: '#fd7e14', borderWidth: 1.5, data: [], yAxisID: 'y' },
                    { label: 'Volume (×1)', borderColor: '#198754', borderWidth: 1.5, data: [], yAxisID: 'y' },
                    { label: 'Fees (×1)', borderColor: '#0d6efd', borderWidth: 1.5, data: [], yAxisID: 'y1' },
                    { label: 'Penalty (×1000)', borderColor: '#dc3545', borderWidth: 1.5, data: [], yAxisID: 'y1' }
                ] 
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                elements: { point: { radius: 0, hitRadius: 10 } },
                plugins: { 
                    legend: { display: true, position: 'top' },
                    tooltip: { mode: 'index', intersect: false }
                },
                scales: {
                    x: { display: true, ticks: { maxTicksLimit: 15 } },
                    y: {
                        type: 'linear',
                        display: true,
                        position: 'left',
                        title: { display: true, text: 'Bytes (Size/Vol)' }
                    },
                    y1: {
                        type: 'linear',
                        display: true,
                        position: 'right',
                        grid: { drawOnChartArea: false },
                        title: { display: true, text: 'Ratio / Atomic Units' }
                    }
                }
            }
        });
    }

    // --- CORE SIMULATION LOGIC (CORRECTED) ---
    function runSimulationLogic(cfg) {
        // Unpacking Configuration
        const n = cfg.n;
        const Z_M = cfg.z_m;
        const T_R = cfg.t_r;
        const R_Base = cfg.r_base;
        let T_sim = cfg.t_sim;
        const LARGE_SIMULATION_MODE = cfg.largeSimMode;
        
        // Window Setup
        const mid_100k = cfg.mid_100k;
        const mid_100 = cfg.mid_100;
        const len_L = mid_100k * 2;  // 100000
        const len_S = mid_100 * 2;   // 100

        // Initialization - matches Python exactly
        let M_B = 0;
        let F_T = 0;
        let M_L_prev = cfg.steadyState;
        
        // Initialize lists with steady state values (matches Python)
        let M_L_list = new Array(len_L).fill(cfg.steadyState);
        let sorted_M_L_list = [...M_L_list].sort((a, b) => a - b);
        
        let M_S_list = new Array(len_S).fill(cfg.steadyState);
        let sorted_M_S_list = [...M_S_list].sort((a, b) => a - b);

        let mempool = [0, 0];
        let fees = [0, 0];
        let broadcast = [0, 0];
        let blockfilled = [0, 0];
        let percent_response = 0;
        
        // LARGE_SIMULATION_MODE variables
        let T_sim_counter = 0;
        let T_sim_reset_counter = 0;

        // Data Storage - expanded to match Python archives
        let results = { 
            M_B: [], 
            M_L: [],
            M_S: [],
            M_N: [],
            M_L_weight: [],
            M_S_weight: [],
            input_volume: [], 
            block_fee: [], 
            penalty: [], 
            mempool_size: [],
            F_T: [],
            f_I: [],
            B: [],
            T_sim: [],
            indices: [] 
        };
        
        let M_B_archive = [];  // Full archive for LARGE_SIMULATION_MODE checks
        
        let max_MB = 0, max_Penalty = 0, max_Mempool = 0;
        let sampleRate = Math.max(1, Math.ceil(n / 1000));

        for (let i = 0; i < n; i++) {
            
            // ============================================
            // 1. MEDIAN CALCULATIONS (matches Python order)
            // ============================================
            
            // M_L = median of sorted_M_L_list
            // Python: M_L = (sorted_M_L_list[mid_100k] + sorted_M_L_list[~mid_100k]) / 2
            // ~mid_100k in Python is -(mid_100k+1), which for index is len-1-mid_100k
            let idx_L1 = mid_100k;
            let idx_L2 = sorted_M_L_list.length - 1 - mid_100k;
            let M_L = (sorted_M_L_list[idx_L1] + sorted_M_L_list[idx_L2]) / 2;
            
            // M_L_weight uses PREVIOUS M_B (from last iteration), stored in M_B variable
            // Python: M_L_weight = max(min(M_B, 1.7 * M_L_prev), Z_M, M_L_prev / 1.7)
            // On first iteration, M_B = 0, so this becomes max(0, Z_M, M_L_prev/1.7) = Z_M
            let M_L_weight = Math.max(Math.min(M_B, 1.7 * M_L_prev), Z_M, M_L_prev / 1.7);
            
            // M_S = median of sorted_M_S_list
            let idx_S1 = mid_100;
            let idx_S2 = sorted_M_S_list.length - 1 - mid_100;
            let M_S = (sorted_M_S_list[idx_S1] + sorted_M_S_list[idx_S2]) / 2;
            
            // M_S_weight = max(M_B, M_L) - uses previous M_B
            let M_S_weight = Math.max(M_B, M_L);
            
            // M_N = min(M_S, 50 * M_L)
            let M_N = Math.min(M_S, 50 * M_L);
            
            // M_B_max = 2 * M_N
            let M_B_max = 2 * M_N;
            
            // Fee calculations
            let f_R = R_Base * T_R / (M_L * M_L);
            let f_I = 0.95 * f_R;
            if (f_I < 1e-12) f_I = 1e-12;
            
            // ============================================
            // 2. LARGE_SIMULATION_MODE T_sim scaling
            // ============================================
            if (LARGE_SIMULATION_MODE) {
                let scale_setting = Math.floor(M_S / Z_M);
                
                if (T_sim <= scale_setting * 800 / 2) {
                    T_sim_counter++;
                    if (T_sim_counter > 500) {
                        for (let j = 0; j < mempool.length; j++) {
                            mempool[j] = Math.floor(mempool[j] / 2);
                        }
                        T_sim *= 2;
                        T_sim_counter = 0;
                    }
                }
                
                if (T_sim >= scale_setting * 800 * 2) {
                    T_sim_counter++;
                    if (T_sim_counter > 500) {
                        for (let j = 0; j < mempool.length; j++) {
                            mempool[j] *= 2;
                        }
                        T_sim /= 2;
                        T_sim_counter = 0;
                    }
                }
                
                if (i > 100) {
                    if (M_B_archive[i-1] === M_B_archive[i-60]) {
                        T_sim_reset_counter++;
                        if (T_sim_reset_counter > 20 && T_sim > 800 && M_S < M_N + T_sim) {
                            for (let j = 0; j < mempool.length; j++) {
                                mempool[j] *= 2;
                            }
                            T_sim /= 2;
                            T_sim_reset_counter = 0;
                        }
                    }
                }
            }
            
            // ============================================
            // 3. BROADCAST NEW TRANSACTIONS
            // ============================================
            blockfilled[0] = 0;
            blockfilled[1] = 0;
            broadcast[0] = 0;
            broadcast[1] = 0;
            
            let vol = 0;
            
            if (cfg.runType === 1) {
                // Linear Ramp
                vol = Z_M + 100 * i;
            } else if (cfg.runType === 2) {
                // Fast Linear Ramp
                vol = Z_M + 800 * i;
            } else if (cfg.runType === 3) {
                // Fast Parabolic Ramp
                vol = Math.pow(316 + (i / 15), 2);
            } else if (cfg.runType === 4) {
                // Fast Exponential Ramp
                vol = Z_M * (Math.pow(1.6, 9.8 + (i / 50000)) - 99.75);
            } else if (cfg.runType === 5) {
                // Maximum flood
                vol = M_B_max;
            } else if (cfg.runType === 6) {
                // Configurable Transaction Ramp To Sine
                let start_val = 300000;
                let ramp_multiplier = cfg.rampMultiplier;
                let ramp_delay = 10;
                let ramp_days = 14;
                let ramp_time = ramp_days * 720;
                
                if (i <= ramp_delay) {
                    vol = start_val;
                } else if (i <= ramp_delay + ramp_time) {
                    vol = start_val + Math.floor((ramp_multiplier - 1) * start_val / ramp_time) * (i - ramp_delay);
                } else {
                    vol = ramp_multiplier * start_val + 220 * Math.sin(i / 802) * 800;
                }
            }
            
            broadcast[1] = Math.floor(vol / T_sim);
            
            // Store input volume before noise
            let input_volume = broadcast[1] * T_sim;
            
            // ADD_NOISE
            if (cfg.addNoise) {
                // Python: noise = 0.2 * np.random.normal(0, broadcast[1], 1)
                let noise = 0.2 * normalRandom(0, broadcast[1]);
                broadcast[1] += Math.floor(noise);
                if (broadcast[1] <= 0) broadcast[1] = 1;
            }
            
            // USERS_PAY_MORE
            if (cfg.usersPayMore) {
                let previous_percent_response = percent_response;
                let percent_response_calc = Math.floor((mempool[1] / (3 * broadcast[1])) * 100);
                if (!isFinite(percent_response_calc)) percent_response_calc = 0;
                percent_response = Math.floor(previous_percent_response + 0.1 * (percent_response_calc - previous_percent_response));
                
                if (percent_response > 100) percent_response = 100;
                if (percent_response > 0 && percent_response <= 100) {
                    broadcast[0] = Math.floor((broadcast[1] * percent_response) / 100);
                    broadcast[1] = Math.floor((broadcast[1] * (100 - percent_response)) / 100);
                }
            }
            
            // Update mempool with broadcast
            for (let j = 0; j < mempool.length; j++) {
                mempool[j] += broadcast[j];
            }
            
            // Define fees paid for each tx fee level
            fees[1] = f_R * T_sim;  // lowest fee
            fees[0] = 16 * fees[1]; // medium fee
            
            // ============================================
            // 4. BUILD NEXT BLOCK
            // ============================================
            M_B = 0;  // Begin building from empty block
            let block_fee_total = 0;
            let fee_set = [];
            let break_flag = false;
            
            for (let k = 0; k < mempool.length; k++) {
                if (break_flag) break;
                
                for (let l = 0; l < mempool[k]; l++) {
                    // Check if we are allowed to grow the block
                    if (M_B >= M_B_max) {
                        blockfilled[0] = k;
                        blockfilled[1] = l;
                        break_flag = true;
                        break;
                    }
                    
                    // Check necessary fees to expand block to new size
                    let B = (M_B / M_N) - 1;
                    let T_T = T_sim;
                    if (T_T > M_B - M_N && M_B - M_N > 0) {
                        T_T = M_B - M_N;
                    }
                    let B_T = T_T / M_N;
                    F_T = R_Base * (2 * B * B_T + B_T * B_T);
                    if (B + B_T <= 0) F_T = 0;
                    
                    fee_set.push(F_T);
                    
                    if (fees[k] < F_T) {
                        blockfilled[0] = k;
                        blockfilled[1] = l;
                        break_flag = true;
                        break;
                    }
                    
                    M_B += T_sim;
                }
            }
            
            // Handle case where all tx were processed
            if (blockfilled[0] === 0 && blockfilled[1] === 0) {
                if (mempool[1] !== 0) {
                    blockfilled[0] = 1;
                    blockfilled[1] = mempool[1];
                } else if (mempool[0] !== 0) {
                    blockfilled[0] = 0;
                    blockfilled[1] = mempool[0];
                }
            }
            
            // Calculate fees paid to create block
            // Python: block_fee_total += (blockfilled[1] - 1) * fees[blockfilled[0]]
            for (let k = 0; k < blockfilled[0]; k++) {
                block_fee_total += mempool[k] * fees[k];
            }
            block_fee_total += (blockfilled[1] - 1) * fees[blockfilled[0]];  // FIXED: -1
            
            // Remove included tx from mempool
            for (let k = 0; k < blockfilled[0]; k++) {
                mempool[k] = 0;
            }
            mempool[blockfilled[0]] -= blockfilled[1];
            if (mempool[blockfilled[0]] < 0) mempool[blockfilled[0]] = 0;
            
            // ============================================
            // 5. PENALTY CALCULATION
            // ============================================
            let B_final = (M_B / M_N) - 1;
            let P_B = R_Base * (B_final * B_final);
            if (B_final <= 0) P_B = 0;
            
            // ============================================
            // 6. UPDATE MEDIAN LISTS
            // ============================================
            // Update Long Term Median Lists
            let old_L = M_L_list.shift();
            removeValue(sorted_M_L_list, old_L);
            M_L_list.push(M_L_weight);
            insort(sorted_M_L_list, M_L_weight);
            
            // Update Short Term Median Lists
            let old_S = M_S_list.shift();
            removeValue(sorted_M_S_list, old_S);
            M_S_list.push(M_S_weight);
            insort(sorted_M_S_list, M_S_weight);
            
            // Store M_L for calculation in next block
            M_L_prev = M_L;
            
            // Store M_B for archive (needed for LARGE_SIMULATION_MODE)
            M_B_archive.push(M_B);
            
            // ============================================
            // 7. STORE DATA FOR PLOTTING
            // ============================================
            let mempool_size_bytes = (mempool[0] + mempool[1]) * T_sim;
            if (mempool_size_bytes > max_Mempool) max_Mempool = mempool_size_bytes;
            if (M_B > max_MB) max_MB = M_B;
            if (P_B > max_Penalty) max_Penalty = P_B;
            
            // Sample data points for charting
            if (i % sampleRate === 0) {
                results.indices.push(i);
                results.M_B.push(M_B);
                results.M_L.push(M_L);
                results.M_S.push(M_S);
                results.M_N.push(M_N);
                results.M_L_weight.push(M_L_weight);
                results.M_S_weight.push(M_S_weight);
                results.input_volume.push(input_volume);
                results.block_fee.push(block_fee_total);
                results.penalty.push(P_B);
                results.mempool_size.push(mempool_size_bytes);
                results.F_T.push(F_T);
                results.f_I.push(f_I);
                results.B.push(B_final);
                results.T_sim.push(T_sim);
            }
        }

        results.stats = { max_MB, max_Penalty, max_Mempool };
        return results;
    }

    // --- UI INTERACTION ---
    function startSimulation() {
        document.getElementById('loadingOverlay').style.display = 'flex';
        
        setTimeout(() => {
            const getVal = (id) => parseFloat(document.getElementById(id).value);
            const getInt = (id) => parseInt(document.getElementById(id).value);
            
            const config = {
                n: getInt('n'),
                steadyState: getInt('steady_state'),
                z_m: getInt('z_m'),
                t_r: getInt('t_r'),
                r_base: getVal('r_base'),
                mid_100k: getInt('mid_100k'),
                mid_100: getInt('mid_100'),
                t_sim: getInt('t_sim'),
                runType: getInt('run_type'),
                rampMultiplier: getVal('ramp_multiplier'),
                addNoise: document.getElementById('add_noise').checked,
                usersPayMore: document.getElementById('users_pay_more').checked,
                largeSimMode: document.getElementById('large_sim_mode').checked
            };

            const t0 = performance.now();
            const data = runSimulationLogic(config);
            const t1 = performance.now();

            // Store raw data for rescaling
            rawSimData = data;

            // Update Single Charts
            updateChart(charts.blockSize, data.indices, data.M_B);
            updateChart(charts.mempool, data.indices, data.mempool_size);
            updateChart(charts.volume, data.indices, data.input_volume);
            updateChart(charts.fees, data.indices, data.block_fee);
            updateChart(charts.penalty, data.indices, data.penalty);
            updateChart(charts.ml, data.indices, data.M_L);
            updateChart(charts.ms, data.indices, data.M_S);

            // Update Combined Chart with current scale settings
            charts.combined.data.labels = data.indices;
            updateCombinedChart();

            document.getElementById('statsOutput').innerHTML = `
                <strong>Calculation Time:</strong> ${(t1-t0).toFixed(0)}ms<br>
                <strong>Max Block Size:</strong> ${(data.stats.max_MB/1000).toFixed(1)} kB<br>
                <strong>Max Mempool:</strong> ${(data.stats.max_Mempool/1000000).toFixed(2)} MB<br>
                <strong>Max Penalty:</strong> ${data.stats.max_Penalty.toFixed(6)}<br>
                <strong>Data Points:</strong> ${data.M_B.length}<br>
                <strong>Final M_L:</strong> ${(data.M_L[data.M_L.length-1]/1000).toFixed(1)} kB<br>
                <strong>Final M_S:</strong> ${(data.M_S[data.M_S.length-1]/1000).toFixed(1)} kB
            `;

            document.getElementById('loadingOverlay').style.display = 'none';
        }, 50);
    }

    function updateChart(chart, labels, data) {
        chart.data.labels = labels;
        chart.data.datasets[0].data = data;
        chart.update();
    }

    window.onload = initCharts;

</script>
</body>
</html> 
